(load "src/gpp_lexer.lisp")

(defun parse-expr (tokens)
  (cond
    ((null tokens) (values nil tokens))
    ((eq (first tokens) 'IDENTIFIER) (values (first tokens) (rest tokens)))
    ((eq (first tokens) 'VALUEF) (values (first tokens) (rest tokens)))
    ((eq (first tokens) 'VALUEI) (values (first tokens) (rest tokens)))
    ((eq (first tokens) 'KW_TRUE) (values (first tokens) (rest tokens)))
    ((eq (first tokens) 'KW_FALSE) (values (first tokens) (rest tokens)))
    ((eq (first tokens) 'OP_OP)
     (cond
       ((member (second tokens) '(OP_PLUS OP_MINUS OP_MULT OP_DIV KW_AND KW_OR KW_LESS KW_EQUAL))
        (parse-arith tokens))
       ((eq (second tokens) 'KW_LOAD) (parse-load tokens))
       ((eq (second tokens) 'KW_SET) (parse-assignment tokens))
       ((eq (second tokens) 'KW_DISP) (parse-display tokens))
       ((eq (second tokens) 'KW_EXIT) (parse-exit tokens))
       ((eq (second tokens) 'KW_IF) (parse-if tokens))
       ((eq (second tokens) 'KW_WHILE) (parse-while tokens))
       ((eq (second tokens) 'KW_FOR) (parse-for tokens))
       ((eq (second tokens) 'KW_DEFFUN) (parse-function-def tokens))
       ((eq (second tokens) 'KW_LIST) (parse-list tokens))
       ((parse-fcall tokens))
       (t (values nil tokens))))
    (t (values nil tokens))))

(defun parse-arith (tokens)
  (cond
    ((and (eq (first tokens) 'OP_OP) (member (second tokens) '(OP_PLUS OP_MINUS OP_MULT OP_DIV KW_AND KW_OR KW_LESS KW_EQUAL)))
     (multiple-value-bind (expr1 remaining-tokens1) (parse-expr (cddr tokens))
       (multiple-value-bind (expr2 remaining-tokens2) (parse-expr remaining-tokens1)
         (if (and expr1 expr2 (eq (first remaining-tokens2) 'OP_CP))
             (values t (rest remaining-tokens2))
             (values nil tokens)))))
    (t (values nil tokens))))

(defun parse-fcall (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'IDENTIFIER))
      (multiple-value-bind (expr remaining-tokens) (parse-expr (cddr tokens))
        (if (and expr (eq (first remaining-tokens) 'OP_CP))
            (values t (rest remaining-tokens))
            (values nil tokens)))
      (values nil tokens)))

(defun parse-function-def (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_DEFFUN))
      (let ((remaining-tokens (cddr tokens)))
        (if (and (eq (first remaining-tokens) 'IDENTIFIER)
                 (eq (second remaining-tokens) 'OP_OP)
                 (eq (third remaining-tokens) 'IDENTIFIER)
                 (eq (fourth remaining-tokens) 'OP_CP))
            (multiple-value-bind (expr remaining-tokens2) (parse-expr (cddddr remaining-tokens))
              (if (and expr (eq (first remaining-tokens2) 'OP_CP))
                  (values t (rest remaining-tokens2))
                  (values nil tokens)))
            (values nil tokens)))
      (values nil tokens)))

(defun parse-list (tokens)
  (cond
    ((eq (first tokens) 'KW_NIL) (values t (rest tokens)))
    ((and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_LIST) (eq (third tokens) 'OP_CP))
     (values t (cdddr tokens)))
    (t (values nil tokens))))

(defun parse-assignment (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_SET))
      (let ((remaining-tokens (cddr tokens)))
        (if (and (eq (first remaining-tokens) 'IDENTIFIER))
            (multiple-value-bind (expr remaining-tokens2) (parse-expr (rest remaining-tokens))
              (if (and expr (eq (first remaining-tokens2) 'OP_CP))
                  (values t (rest remaining-tokens2))
                  (values nil tokens)))
            (values nil tokens)))
      (values nil tokens)))

(defun parse-if (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_IF))
      (multiple-value-bind (expr1 remaining-tokens1) (parse-expr (cddr tokens))
        (multiple-value-bind (expr2 remaining-tokens2) (parse-expr remaining-tokens1)
          (if expr2
              (if (eq (first remaining-tokens2) 'OP_CP)
                  (values t (rest remaining-tokens2))
                  (multiple-value-bind (expr3 remaining-tokens3) (parse-expr remaining-tokens2)
                    (if (and expr3 (eq (first remaining-tokens3) 'OP_CP))
                        (values t (rest remaining-tokens3))
                        (values nil tokens))))
              (values nil tokens))))
      (values nil tokens)))

(defun parse-while (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_WHILE))
      (let ((remaining-tokens (cddr tokens)))
        (multiple-value-bind (expr1 remaining-tokens1) (parse-expr remaining-tokens)
          (multiple-value-bind (expr2 remaining-tokens2) (parse-expr remaining-tokens1)
            (if (and expr1 expr2 (eq (first remaining-tokens2) 'OP_CP))
                (values t (rest remaining-tokens2))
                (values nil tokens)))))
      (values nil tokens)))

(defun parse-for (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_FOR))
      (let ((remaining-tokens (cddr tokens)))
        (when (and (eq (first remaining-tokens) 'OP_OP)
                   (eq (second remaining-tokens) 'IDENTIFIER))
          (let ((id (second remaining-tokens))
                (remaining-tokens1 (cddr remaining-tokens)))
            (multiple-value-bind (start-expr remaining-tokens2) (parse-expr remaining-tokens1)
              (multiple-value-bind (end-expr remaining-tokens3) (parse-expr remaining-tokens2)
                (when (and start-expr end-expr (eq (first remaining-tokens3) 'OP_CP))
                  (let ((remaining-tokens4 (rest remaining-tokens3)))
                    (multiple-value-bind (body-expr remaining-tokens5) (parse-expr remaining-tokens4)
                      (when (and body-expr (eq (first remaining-tokens5) 'OP_CP))
                        (values t (rest remaining-tokens5)))))))))))
      (values nil tokens)))

(defun parse-display (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_DISP))
      (multiple-value-bind (expr remaining-tokens) (parse-expr (cddr tokens))
        (if (and expr (eq (first remaining-tokens) 'OP_CP))
            (values t (rest remaining-tokens))
            (values nil tokens)))
      (values nil tokens)))

(defun parse-exit (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_EXIT) (eq (third tokens) 'OP_CP))
      (values t (cdddr tokens))
      (values nil tokens)))

(defun parse-load (tokens)
  (if (and (eq (first tokens) 'OP_OP) (eq (second tokens) 'KW_LOAD))
      (let ((remaining-tokens (cddr tokens)))
        (if (and (eq (first remaining-tokens) 'IDENTIFIER) (eq (second remaining-tokens) 'OP_CP))
            (values t (cdddr remaining-tokens))
            (values nil tokens)))
      (values nil tokens)))

(defun syntax-check (line)
  (let ((tokens (tokenize line)))
    (multiple-value-bind (expr remaining-tokens) (parse-expr tokens)
      (if (and expr (null remaining-tokens))
          (format t "Syntax is correct.~%")
          (format t "Syntax error.~%")))))

(defun read-eval-syntax-check-loop ()
  (loop
    (format t "> ")
    (let ((line (read-line *standard-input* nil)))
      (when line (syntax-check line)))))

(defun gppsyntax (&optional (filename nil))
  (if filename
      (progn
        (with-open-file (stream filename)
          (loop for line = (read-line stream nil)
                while line do
                (syntax-check line)))
        (read-eval-syntax-check-loop))
      (read-eval-syntax-check-loop)))